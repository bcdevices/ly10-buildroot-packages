
Start address of a bank is always set to 0.

This prevents successful verification of data written to
a secondary bank, such as the bootloader bank for EFR32:

flash bank bootloader.flash efm32 0x0FE10000 0 0 0 $_TARGETNAME

See discussion on https://www.silabs.com/community/software/simplicity-studio/forum.topic.html/efm32_developmentde-LqeK

diff --git a/src/flash/nor/efm32.c b/src/flash/nor/efm32.c
index 6461e4c72..b210f208a 100644
--- a/src/flash/nor/efm32.c
+++ b/src/flash/nor/efm32.c
@@ -944,7 +944,7 @@ static int efm32x_probe(struct flash_bank *bank)
 	struct efm32x_flash_bank *efm32x_info = bank->driver_priv;
 	struct efm32_info efm32_mcu_info;
 	int ret;
-	uint32_t base_address = 0x00000000;
+	// uint32_t base_address = 0x00000000;
 
 	efm32x_info->probed = false;
 	memset(efm32x_info->lb_page, 0xff, LOCKBITS_PAGE_SZ);
@@ -968,7 +968,7 @@ static int efm32x_probe(struct flash_bank *bank)
 	free(bank->sectors);
 	bank->sectors = NULL;
 
-	bank->base = base_address;
+	// bank->base = base_address;
 	bank->size = (num_pages * efm32_mcu_info.page_size);
 	bank->num_sectors = num_pages;
 

 

