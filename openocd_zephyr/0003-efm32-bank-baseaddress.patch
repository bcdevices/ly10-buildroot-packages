
Start address of a bank is always set to 0.

This prevents successful verification of data written to
a secondary bank, such as the bootloader bank for EFR32:

flash bank bootloader.flash efm32 0x0FE10000 0 0 0 $_TARGETNAME

See discussion on https://www.silabs.com/community/software/simplicity-studio/forum.topic.html/efm32_developmentde-LqeK

diff --git a/src/flash/nor/efm32.c b/src/flash/nor/efm32.c
index 6f2900762..48fbd6443 100644
--- a/src/flash/nor/efm32.c
+++ b/src/flash/nor/efm32.c
@@ -960,7 +960,7 @@ static int efm32x_probe(struct flash_bank *bank)
 	struct efm32x_flash_bank *efm32x_info = bank->driver_priv;
 	struct efm32_info efm32_mcu_info;
 	int ret;
-	uint32_t base_address = 0x00000000;
+	//uint32_t base_address = 0x00000000;
 	char buf[256];
 
 	efm32x_info->probed = false;
@@ -988,7 +988,7 @@ static int efm32x_probe(struct flash_bank *bank)
 	free(bank->sectors);
 	bank->sectors = NULL;
 
-	bank->base = base_address;
+	//bank->base = base_address;
 	bank->size = (num_pages * efm32_mcu_info.page_size);
 	bank->num_sectors = num_pages;
 

